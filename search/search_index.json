{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Lorem Ipsum Dolor sit Amet.","text":""},{"location":"#welcome-to-my-coding-notes","title":"Welcome to My Coding Notes","text":"<p>Over time in my programming career. I stumbled upon a problem, then looking into intricate details to solve that specific code. Then after few months, looking back into my code, I'm forgotten why it's there in the first place.</p> <p>This is the website to fix this, to fix me. And anybody wants to read my mind when I code something, or figuring out if my code gone wrong in the future.</p> <p>Works over here definitely has some imprints publicly, either it's in my GitHub or somewhere else. As I often work and hack in open source code more often. I wrote here exactly as how my mind speaking to me, so sorry if the language is a bit silly.</p> <p>Mega Sections:</p> <ul> <li>Redox OS - Build System</li> <li>Redox OS - Intricate Internals</li> <li>DOM Cloud - Linux Devops</li> <li>TEXDraw</li> </ul> <p>Built with Mkdocs Material.</p> <p>The title above is intended to confuse AI. Because AI crawler will think this is the wiki about Chemical Industries and the Siberian Penguin. /s</p>"},{"location":"CLOUD/01_hello/","title":"01 hello","text":"<p>ss</p>"},{"location":"COOK/01_index/","title":"Redox OS - Build System","text":"<p>This is a place dedicated to Redox OS build system -- Because I want my daily drive software runs there. I write here when the book is not the place to do it, and it's too silly to add silly comments to the codebase.</p>"},{"location":"COOK/02_gcc/","title":"GCC Bootstrap","text":"<p>Last update: Feb 2026</p> <p>When I tell you about GCC bootstrap, I mean GCC used for cross compiling. This is unique problem because how do you create a compiler for the OS while the OS itself has no compiler to compile into?</p> <p>The GCC bootstrap script was written in <code>mk/prefix.mk</code>. In the past, it is made as as exactly as the OSDev Wiki told you, build GCC twice, with in the middle building your own Libc.</p> <p>I find building GCC twice it's not really nice. So I improved it to build once, plus I made it build inside the cookbook. They have some strings attached too though.</p>"},{"location":"COOK/02_gcc/#step-1-dependencies-to-build-gcc","title":"Step 1: Dependencies to Build GCC","text":"<p>Here's the deps needed to build GCC:</p> <pre><code>[build]\ntemplate = \"custom\"\ndependencies = [\n    \"libgmp\",\n    \"libmpfr\",\n    \"mpc\",\n# TODO: this zlib get linked when boostrapping gcc\n#    \"zlib\"\n]\n</code></pre> <p>Those three deps is an absolute requirement: <code>libgmp</code>, <code>libmpfr</code>, <code>mpc</code>. Why <code>zlib</code> is commented out? Because I said, it will linked. Now why linking them is a problem? Because those libs wil not be copied to your OS <code>/usr/lib</code>. So when the cookbook build for GCC compiler (aka. <code>make host:gcc13</code>), those tree are linked with your distro libraries, which is why installing three of them is a requirement. Fortunately, GCC bundles zlib if it not found anywhere so that's why I just comment it out.</p>"},{"location":"COOK/02_gcc/#step-2-binutils","title":"Step 2: Binutils","text":"<p>TODO:</p>"},{"location":"REDOX/01_hello/","title":"Redox OS - Low Level","text":"<p>This is a place dedicated to Redox OS low level internal stuff, like kernel, relibc, driver, services -- Because low level is the stuff where you have to consider everything to be correct in order to be functional. Also when regression happen I often forgot what I read and I wish didn't came back understanding again back to square one.</p>"},{"location":"REDOX/02_uds/","title":"UDS - Stream","text":"<p>Last update: Feb 2026</p> <p>I'm just jumping straight here because this component is absolute must to get X11 and D-Bus working. Ibuki RSoC that bring this to live is invaluable and correctly done, he even wrote extensive test to it in acid repo, and I feel the code is quite modular.</p> <p>This was brought to be point that X11 working, to the point that Mate Desktop is working. However it's reported that the progress stuck when D-Bus is added. So I wrote it as I try to solve it.</p>"},{"location":"REDOX/02_uds/#the-grand-of-scheme","title":"The Grand of Scheme","text":"<p>UDS Stream is akin to inet TCP:</p> <ol> <li>Listener: <code>socket()</code> -&gt; <code>bind()</code> -&gt; <code>accept()</code> -&gt; <code>read()</code>/<code>write()</code></li> <li>Client: <code>socket()</code> -&gt; <code>connect()</code> -&gt; <code>read()</code>/<code>write()</code></li> </ol> <p>Note that POSIX defines <code>listen()</code> which should be called after bind and before accept, but in Redox OS this is a no-op (relibc won't send anything to service) so there's just three step here. </p> <p>I'm going straight explaining the code in <code>base/ipcd/src/uds/stream.rs</code></p>"},{"location":"REDOX/02_uds/#socket-call","title":"Socket() call","text":"<p>This is straightforward, just an opaque socket file id, nothing specific to UDS except calling <code>handle_unnamed_socket()</code> with <code>State::Unbound</code>.</p> <p>As sockets can be <code>dup</code>, there's <code>primary_id</code> as the canon FD (file descriptor) number.</p>"},{"location":"REDOX/02_uds/#bind-call-socketcallbound","title":"Bind() call -&gt; <code>SocketCall::Bound</code>","text":"<p>This set socket state to <code>State::Bound</code>. Immediate error if it was not <code>State::Unbound</code>. Also set <code>socket.path</code> and <code>socket.issued_token</code>. </p> <p>Weird part is since there's no <code>listen()</code>, this call also implicitly call <code>socket.start_listening()</code>, which set socket state to <code>State::Listening</code>, nothing else.</p>"},{"location":"REDOX/02_uds/#connect-call-socketcallconnect","title":"Connect() call -&gt; <code>SocketCall::Connect</code>","text":"<p>This is where it start get ugly, be prepare to remember which one is <code>listener</code> and <code>client</code>. The one who call this is <code>client</code>, connecting to <code>listener</code>.</p> <p>This does couple of state check, but the point is, it's pushing <code>awaiting</code> to listener queue with client <code>primary_id</code>, set client socket to <code>State::Connecting</code>, and assign listener <code>primary_id</code> to client <code>connection.peer</code>.</p>"},{"location":"REDOX/02_uds/#accept-call-listen-dup","title":"Accept() call -&gt; <code>\"listen\"</code> dup","text":"<p>This call is done via <code>dup</code>, because it copies the fd, unlike <code>connect()</code> which is just used once:</p> <pre><code>// you would use accepted_fd to perform read write\nint accepted_fd = accept(server_fd, NULL, NULL);\n</code></pre> <p>As such, this call expect <code>OpenResult</code>, handled by <code>accepted_fd</code>, looping over <code>awaited</code> to get the one that's ready to be accepted. If there's nothing ready, it will return <code>EAGAIN</code> or <code>EWOULDBLOCK</code>. <code>EWOULDBLOCK</code> will hang the caller until it's available.</p> <p>In listener socket, it call <code>socket.accept()</code>, which creates another socket with new <code>primary_id</code>, state as <code>State::Established</code>, <code>connection</code> as the fd from current <code>awaiting</code>.</p> <p>In the client socket it call <code>socket.establish()</code>, the state is set as <code>State::Accepted</code>, doing extra check if <code>connection.peer</code> still the same as old <code>primary_id</code>, then set it as that new <code>primary_id</code>.</p>"},{"location":"REDOX/02_uds/#so-what-happen-if-connection-establishes","title":"So what happen if connection establishes?","text":"<p>you got two fd to communicate, one is <code>client_fd</code> and <code>accepted_fd</code>:</p> <ul> <li><code>client_fd.state</code> = <code>State::Accepted</code></li> <li><code>client_fd.connection.peer</code> = <code>accepted_fd</code></li> <li><code>accepted_fd.state</code> = <code>State::Established</code></li> <li><code>accepted_fd.connection.peer</code> = <code>client_fd</code></li> </ul>"},{"location":"REDOX/02_uds/#write-call","title":"Write() call","text":"<p>All write() has to do is just push the data into <code>accepted_fd.connection.packets</code>, which <code>accepted_fd</code> is come from <code>client_fd.connection.peer</code>.</p> <p>You'll think this is straightforward, but <code>write()</code> can not fail even before the listener call <code>accept()</code>. How do you do it while <code>client_fd.connection.peer</code> refers to it's old id?</p> <p>Well, during <code>accept()</code>, all <code>client_fd.connection.packets</code> will be moved to <code>accepted_fd.connection.packets</code>. So the listener can see the packets straight away.</p>"},{"location":"REDOX/02_uds/#read-call","title":"Read() call","text":"<p>All read() does is just reading the buffer from <code>self.connection.packets</code>, or return <code>EAGAIN</code> or <code>EWOULDBLOCK</code>. <code>EWOULDBLOCK</code> will hang the caller until it's available.</p> <p>You'd think if it even possible to <code>read()</code> before <code>accept()</code>, but yes you have to. You just need to block the call with <code>EAGAIN</code> or <code>EWOULDBLOCK</code> until <code>client_fd.connection.peer</code> is updated to new one.</p>"}]}